<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Get conformal prediction sets — getPredictionSets • scConform</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Get conformal prediction sets — getPredictionSets"><meta property="og:description" content="This function returns prediction sets for the cell
type of cells in a SingleCellExperiment objects.
It implements two methods: the first one uses standard conformal inference,
while the second one conformal risk control (see details). The output is
either a SingleCellExperiment object with the prediction sets in the colData
or a list."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">scConform</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.99.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/scConform.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/ccb-hms/scConform/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Get conformal prediction sets</h1>
    <small class="dont-index">Source: <a href="https://github.com/ccb-hms/scConform/blob/HEAD/R/getPredictionSets.R" class="external-link"><code>R/getPredictionSets.R</code></a></small>
    <div class="hidden name"><code>getPredictionSets.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function returns prediction sets for the cell
type of cells in a SingleCellExperiment objects.
It implements two methods: the first one uses standard conformal inference,
while the second one conformal risk control (see details). The output is
either a SingleCellExperiment object with the prediction sets in the colData
or a list.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">getPredictionSets</span><span class="op">(</span></span>
<span>  <span class="va">x_query</span>,</span>
<span>  <span class="va">x_cal</span>,</span>
<span>  <span class="va">y_cal</span>,</span>
<span>  onto <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  alpha <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>  lambdas <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.001</span>, <span class="fl">0.999</span>, length.out <span class="op">=</span> <span class="fl">100</span><span class="op">)</span>,</span>
<span>  follow_ontology <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  resample_cal <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  labels <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  return_sc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pr_name <span class="op">=</span> <span class="st">"pred.set"</span>,</span>
<span>  simplify_pred <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  BPPARAM <span class="op">=</span> <span class="fu">SerialParam</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>x_query</dt>
<dd><p>query data for which we want to build prediction sets. Could
be either a SingleCellExperiment object with the estimated probabilities for
each cell type in the colData, or a named matrix of dimension <code>n x K</code>,
where <code>n</code> is the number of cells and <code>K</code> is the number of different
labels. The colnames of the matrix have to correspond to the cell labels.</p></dd>


<dt>x_cal</dt>
<dd><p>calibration data. Could be either a
SingleCellExperiment object with the estimated probabilities for each cell
type in the colData, or a named matrix of dimension <code>m x K</code>, where
<code>m</code> is the number of cells and <code>K</code> is the number of different
labels. The colnames of the matrix have to correspond to the cell labels.</p></dd>


<dt>y_cal</dt>
<dd><p>a vector of length <code>m</code> with the true labels of the cells in
the calibration data.</p></dd>


<dt>onto</dt>
<dd><p>the considered section of the cell ontology as an igraph object.</p></dd>


<dt>alpha</dt>
<dd><p>a number between 0 and 1 that indicates the allowed miscoverage</p></dd>


<dt>lambdas</dt>
<dd><p>a vector of possible lambda values to be considered. Necessary
only when <code>follow_ontology=TRUE</code>.</p></dd>


<dt>follow_ontology</dt>
<dd><p>If <code>TRUE</code>, then the function returns hierarchical
prediction sets that follow the cell ontology structure. If <code>FALSE</code>, it
returns classical conformal prediction sets. See details.</p></dd>


<dt>resample_cal</dt>
<dd><p>Should the calibration dataset be resampled according to
the estimated relative frequencies of cell types in the query data?</p></dd>


<dt>labels</dt>
<dd><p>labels of different considered cell types. Necessary if
<code>onto=NULL</code>, otherwise they are set equal to the leaf nodes of the
provided graph.</p></dd>


<dt>return_sc</dt>
<dd><p>parameter the controls the output. If <code>TRUE</code>, the
function returns a SingleCellExperiment.
If <code>FALSE</code>, the function returns a list. By default,
it is set to <code>TRUE</code> when <code>x_query</code> is a SingleCellExperiment or
SpatialExperiment object and to <code>FALSE</code> when <code>x_query</code> is a matrix.</p></dd>


<dt>pr_name</dt>
<dd><p>name of the colData variable in the returned
SingleCellExperiment object that will contain the prediction
sets. The default name is <code>pred.set</code>.</p></dd>


<dt>simplify_pred</dt>
<dd><p>if <code>TRUE</code>, the output will be the common ancestor
of the labels inserted into the prediction set. If <code>FALSE</code> (default),
the output will be the set of the leaf labels.</p></dd>


<dt>BPPARAM</dt>
<dd><p>BiocParallel instance for parallel computing. Default is
<code>SerialParam()</code>.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    <dl><dt><code>return_sc = TRUE</code></dt>
<dd><p>the function <code>getPredictionSets</code> returns
a SingleCellExperiment or SpatialExperiment
object with the prediction sets in the colData. The name of the variable
containing the prediction sets is given by the parameter <code>pr_name</code></p></dd>

<dt><code>return_sc = FALSE</code></dt>
<dd><p>the function <code>getPredictionSets</code> returns
a list of length equal
to the number of cells in the test data. Each element of the list contains
the prediction set for that cell.</p></dd>

</dl></div>
    <div id="details">
    <h2>Details</h2>
    
<div class="section">
<h3 id="split-conformal-sets">Split conformal sets<a class="anchor" aria-label="anchor" href="#split-conformal-sets"></a></h3>
<p>Conformal inference is a statistical
framework that allows to build
prediction sets for any probabilistic or machine learning model. Suppose we
have a classification task with \(K\) classes. We fit a classification
model \(\hat{f}\) that outputs estimated probabilities for each class:
\(\hat{f}(x) \in [0,1]^K\). Split conformal inference requires to reserve a
portion of the labelled training data, \((X_1,Y_1),\dots, (X_n,Y_n)\), to
be used as calibration data. Given \(\hat{f}\) and the calibration data,
the objective of conformal inference is to build, for a new observation
\(X_{n+1},\) a prediction set \(C(X_{n+1}) \subseteq\{1,\dots,K\}\) that
satisfies
$$P\left(Y_{n+1}\in C(X_{n+1})\right) \geq 1-\alpha$$
for a user-chosen error rate \(\alpha\). Note that conformal inference is
distribution-free and the sets provided have finite-samples validity.
The only assumption is that the test data and the calibration data are
exchangeable. The algorithm of split conformal inference is the following:</p><ol><li><p>For the data in the calibration set, \((X_1,Y_1),\dots, (X_n,Y_n)\)
  , obtain the <em>conformal scores</em>, \(s_i=1-\hat{f}(X_i)_{Y_i},
  \;i=1,\dots,n\). These scores will be high when the model is assigning a
  small probability to the true class, and low otherwise.</p></li>
<li><p>Obtain \(\hat{q}\), the
  \(\lceil(1-\alpha)(n+1)\rceil/n\) empirical quantile of the conformal
  scores.</p></li>
<li><p>Finally, for a new observation \(X_{n+1}\), construct a prediction
  set by including all the classes for which the estimated probability is
  higher than \(1-\hat{q}\):
  $$C(X_{n+1})=\{y: \hat{f}(X_{n+1})_y\geq 1-\hat{q}\}.$$</p></li>
</ol></div>
<div class="section">
<h3 id="hierarchical-conformal-sets">Hierarchical conformal sets<a class="anchor" aria-label="anchor" href="#hierarchical-conformal-sets"></a></h3>
<p>Let \(\hat{y}(x)\) be the class with maximum estimated probability.
Moreover, given a directed graph let \(\mathcal{P}(v)\) and
\(\mathcal{A}(v)\) be the set on children nodes and ancestor nodes of
\(v\), respectively. Finally, for each node \(v\) define a score
\(g(v,x)\) as the sum of the predicted probabilities of the leaf nodes that
are children of \(v\).
To build the sets we propose the following algorithm: $$\mathcal{P}(v)
\cup \{\mathcal{P}(a): a\in\mathcal{A}(\hat{y}(x)): g(a,x)\leq\lambda \},$$
where \(v:v\in \mathcal{A}(\hat{y}(x)), \;g(v,x)\geq\lambda,\;
v=\arg\min_{u:g(u,x)\geq\lambda}g(u,x)\).
In words, we start from the predicted class and we go up in the graph until
we find an ancestor of \(\hat{y}(x)\) that has a score that is at least
\(\lambda\) and include in the prediction sets all its children.
For theoretical reasons, to this subgraph we add all the other
ones that contain \(\hat{y}(x)\) for which the score is less than
\(\lambda\). To choose \(\lambda\), we follow eq. (4) in Angelopoulus et
al. (2023), considering the miscoverage as loss function. In this way, it is
still guaranteed that
$$P(Y_{n+1}\notin C_\lambda (X_{n+1})) \leq \alpha.$$</p>
</div>

    </div>
    <div id="references">
    <h2>References</h2>
    <p>For an introduction to conformal prediction, see
Angelopoulos, Anastasios N., and Stephen Bates. "A gentle introduction to
conformal prediction and distribution-free uncertainty quantification."
arXiv preprint arXiv:2107.07511 (2021).
For reference on conformal risk control, see
Angelopoulos, Anastasios N., et al. "Conformal risk control."
arXiv preprint arXiv:2208.02814 (2023).</p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># random p matrix</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1040</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">2000</span> <span class="op">*</span> <span class="fl">4</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Normalize the matrix p to have all numbers between 0 and 1 that sum to 1</span></span></span>
<span class="r-in"><span><span class="co"># by row</span></span></span>
<span class="r-in"><span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">p</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">p</span>, <span class="fl">1</span>, <span class="va">max</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">p</span> <span class="op">&lt;-</span> <span class="va">p</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">p</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">cell_types</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"T (CD4+)"</span>, <span class="st">"T (CD8+)"</span>, <span class="st">"B"</span>, <span class="st">"NK"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">cell_types</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Take 1000 rows as calibration and 1000 as test</span></span></span>
<span class="r-in"><span><span class="va">p_cal</span> <span class="op">&lt;-</span> <span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">1000</span>, <span class="op">]</span></span></span>
<span class="r-in"><span><span class="va">p_test</span> <span class="op">&lt;-</span> <span class="va">p</span><span class="op">[</span><span class="fl">1001</span><span class="op">:</span><span class="fl">2000</span>, <span class="op">]</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Randomly create the vector of real cell types for p_cal and p_test</span></span></span>
<span class="r-in"><span><span class="va">y_cal</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="va">cell_types</span>, <span class="fl">1000</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">y_test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="va">cell_types</span>, <span class="fl">1000</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Obtain conformal prediction sets</span></span></span>
<span class="r-in"><span><span class="va">conf_sets</span> <span class="op">&lt;-</span> <span class="fu">getPredictionSets</span><span class="op">(</span></span></span>
<span class="r-in"><span>    x_query <span class="op">=</span> <span class="va">p_test</span>,</span></span>
<span class="r-in"><span>    x_cal <span class="op">=</span> <span class="va">p_cal</span>,</span></span>
<span class="r-in"><span>    y_cal <span class="op">=</span> <span class="va">y_cal</span>,</span></span>
<span class="r-in"><span>    onto <span class="op">=</span> <span class="cn">NULL</span>,</span></span>
<span class="r-in"><span>    alpha <span class="op">=</span> <span class="fl">0.1</span>,</span></span>
<span class="r-in"><span>    follow_ontology <span class="op">=</span> <span class="cn">FALSE</span>,</span></span>
<span class="r-in"><span>    resample_cal <span class="op">=</span> <span class="cn">FALSE</span>,</span></span>
<span class="r-in"><span>    labels <span class="op">=</span> <span class="va">cell_types</span>,</span></span>
<span class="r-in"><span>    return_sc <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Corbetta Daniela.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

      </footer></div>

  


  

  </body></html>

